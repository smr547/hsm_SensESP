//$file${.::main.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qhsmtst.qm
// File:  ${.::main.cpp}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::main.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

#include <Arduino.h>

#include "qpcpp.hpp"    // QP/C++ framework
#include "qhsmtst.hpp"  // QHsmTst state machine
#include "esp_sleep.h"
#include <memory>

#include "sensesp.h"
#include "sensesp/sensors/analog_input.h"
#include "sensesp/sensors/digital_input.h"
#include "sensesp/sensors/sensor.h"
#include "sensesp/signalk/signalk_output.h"
#include "sensesp/system/lambda_consumer.h"
#include "sensesp_app_builder.h"

using namespace sensesp;

std::uint32_t APP::chainCount;
auto count_producer = std::make_shared<ObservableValue<int>>(0);

// The setup function performs one-time application initialization.
void setup() {

    Serial.begin(115200);
    APP::the_sm->init(0U);  // trigger the initial tran. in the test SM
    Serial.print("Waiting for input >>> ");


  SetupLogging(ESP_LOG_NONE);

  // Construct the global SensESPApp() object
  SensESPAppBuilder builder;
  sensesp_app = (&builder)
                    // Set a custom hostname for the app.
                    ->set_hostname("SouthSky-Chain-Counter")
                    // Optionally, hard-code the WiFi and Signal K server
                    // settings. This is normally not needed.
                    //->set_wifi_client("My WiFi SSID", "my_wifi_password")
                    //->set_wifi_access_point("My AP SSID", "my_ap_password")
                    //->set_sk_server("192.168.10.3", 80)
                    ->get_app();

  // GPIO number to use for the analog input
  const uint8_t kAnalogInputPin = 36;
  // Define how often (in milliseconds) new samples are acquired
  const unsigned int kAnalogInputReadInterval = 500;
  // Define the produced value at the maximum input voltage (3.3V).
  // A value of 3.3 gives output equal to the input voltage.
  const float kAnalogInputScale = 3.3;

  // Create a new Analog Input Sensor that reads an analog input pin
  // periodically.
  auto analog_input = std::make_shared<AnalogInput>(
      kAnalogInputPin, kAnalogInputReadInterval, "", kAnalogInputScale);

  // Add an observer that prints out the current value of the analog input
  // every time it changes.
  analog_input->attach([analog_input]() {
    debugD("Analog input value: %f", analog_input->get());
  });

  // Set GPIO pin 15 to output and toggle it every 650 ms

  const uint8_t kDigitalOutputPin = 15;
  const unsigned int kDigitalOutputInterval = 650;
  pinMode(kDigitalOutputPin, OUTPUT);
  event_loop()->onRepeat(kDigitalOutputInterval, [kDigitalOutputPin]() {
    digitalWrite(kDigitalOutputPin, !digitalRead(kDigitalOutputPin));
  });

  // Read GPIO 14 every time it changes

  const uint8_t kDigitalInput1Pin = 14;
  auto digital_input1 = std::make_shared<DigitalInputChange>(
      kDigitalInput1Pin, INPUT_PULLUP, CHANGE);

  // Connect the digital input to a lambda consumer that prints out the
  // value every time it changes.

  // Test this yourself by connecting pin 15 to pin 14 with a jumper wire and
  // see if the value changes!

  auto digital_input1_consumer = std::make_shared<LambdaConsumer<bool>>(
      [](bool input) { debugD("Digital input value changed: %d", input); });

  digital_input1->connect_to(digital_input1_consumer);

  // Create another digital input, this time with RepeatSensor. This approach
  // can be used to connect external sensor library to SensESP!

  const uint8_t kDigitalInput2Pin = 13;
  const unsigned int kDigitalInput2Interval = 1000;

  // Configure the pin. Replace this with your custom library initialization
  // code!
  pinMode(kDigitalInput2Pin, INPUT_PULLUP);

  // Define a new RepeatSensor that reads the pin every 100 ms.
  // Replace the lambda function internals with the input routine of your custom
  // library.

  // Again, test this yourself by connecting pin 15 to pin 13 with a jumper
  // wire and see if the value changes!

  auto digital_input2 = std::make_shared<RepeatSensor<bool>>(
      kDigitalInput2Interval,
      [kDigitalInput2Pin]() { return digitalRead(kDigitalInput2Pin); });

  // Connect the analog input to Signal K output. This will publish the
  // analog input value to the Signal K server every time it changes.
  auto aiv_metadata = std::make_shared<SKMetadata>("V", "Analog input voltage");
  auto aiv_sk_output = std::make_shared<SKOutput<float>>(
      "sensors.analog_input.voltage",   // Signal K path
      "/Sensors/Analog Input/Voltage",  // configuration path, used in the
                                        // web UI and for storing the
                                        // configuration
      aiv_metadata
  );

  ConfigItem(aiv_sk_output)
      ->set_title("Analog Input Voltage SK Output Path")
      ->set_description("The SK path to publish the analog input voltage")
      ->set_sort_order(100);

  analog_input->connect_to(aiv_sk_output);

  // chain counter to SignalK

  auto cc_metadata = std::make_shared<SKMetadata>("", "Chain counter");
  auto cc_sk_output = std::make_shared<SKOutput<int>>(
      "sensors.chain.count",
      "/Sensors/chain/count",
      cc_metadata
  );

  ConfigItem(cc_sk_output)
      ->set_title("Chain Counter SK Output Path")
      ->set_description("The SK path to publish the chain counter count")
      ->set_sort_order(101);

   count_producer->connect_to(cc_sk_output);


  // Connect digital input 2 to Signal K output.
  auto di2_metadata = std::make_shared<SKMetadata>("", "Digital input 2 value");
  auto di2_sk_output = std::make_shared<SKOutput<bool>>(
      "sensors.digital_input2.value",    // Signal K path
     "/Sensors/Digital Input 2/Value",  // configuration path
      di2_metadata
  );

  ConfigItem(di2_sk_output)
      ->set_title("Digital Input 2 SK Output Path")
      ->set_sort_order(200);

  digital_input2->connect_to(di2_sk_output);

  // To avoid garbage collecting all shared pointers created in setup(),
  // loop from here.
  while (true) {
    loop();
  }
}

void loop() {

   char rc;

    if (Serial.available() > 0) {
        rc = Serial.read();
        Serial.print("Read character '");
        Serial.print(rc);
        Serial.println("'");

        QP::QSignal sig = 0U;
        if ('a' <= rc && rc <= 'j') {  // in range?
            sig = (QP::QSignal)(rc - 'a' + APP::A_SIG);
        } else if ('A' <= rc && rc <= 'J') {  // in range?
            sig = (QP::QSignal)(rc - 'A' + APP::A_SIG);
        } else if ((rc == 'x') || (rc == 'X')) {  // x or X?
            sig = APP::TERMINATE_SIG;  // terminate the interactive test
        } else {
            sig = APP::IGNORE_SIG;
        }

        QP::QEvt const e(sig);
        APP::the_sm->dispatch(&e, 0U);  // dispatch the event
    }

// Serial.print("chain counter is: ");
// Serial.print(APP::chainCount);
// Serial.print("\n");
 if (count_producer->get() != APP::chainCount) {
    count_producer->set(APP::chainCount);
Serial.print("chain counter updated to: ");
Serial.print(APP::chainCount);
Serial.print("\n");
 }

 event_loop()->tick();

}


//............................................................................
extern "C" Q_NORETURN Q_onError(char const *const file, int_t const line) {
    // FPRINTF_S(stderr, "Assertion failed in %s, line %d", file, line);
    Serial.println("Assertion failed");
    while (1) {
    }
}

namespace APP {
//............................................................................
void BSP_display(char const *msg) { Serial.println(msg); }
//............................................................................
void BSP_terminate(int16_t const result) {
    Serial.println("Bye Bye");
    while (1) {
    }
}

void BSP_deepSleep() {
    Serial.println("Going to Deep Sleep");
    esp_deep_sleep_start();
    while (1) {
    }
}

}  // namespace APP







